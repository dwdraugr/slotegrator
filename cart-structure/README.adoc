= Структуры корзины заказов

== Текст задания
У нас есть набор действий, которые мы хотим осуществлять с заказами:
[source, php]
----
calculateTotalSum(){/*...*/}
getItems(){/*...*/}
getItemsCount(){/*...*/}
addItem($item){/*...*/}
deleteItem($item){/*...*/}
printOrder(){/*...*/}
showOrder(){/*...*/}
load(){/*...*/}
save(){/*...*/}
update(){/*...*/}
delete(){/*...*/}
----
Нужно создать структуру классов, чтобы можно было пользоваться
этими методами.

== Описание решение

Структура организована следующим образом:

* *Shared* содержит классы данных, `OrderEntity` и `ItemEntity`.
Первый реализует методы взаимодействия с частями заказа:
[source, php]
----
getItems(){/*...*/}
getItemsCount(){/*...*/}
addItem($item){/*...*/}
deleteItem($item){/*...*/}
----

* *Communication* содержит классы взаимодействия со внешней средой, в нашем случае -- двумя типами отображения заказа:
[source, php]
----
printOrder(){/*...*/}
showOrder(){/*...*/}
----

* *Business* содержит класс, отвечающий за бизнес-логику приложения, в данном 
примере - с расчётом суммы заказа:
[source, php]
----
calculateTotalSum(){/*...*/}
----

* *Persistence* содержит классы по сохранению, обновлению и удалению сущностей
приложения
[source, php]
----
load(){/*...*/}
save(){/*...*/}
update(){/*...*/}
delete(){/*...*/}
----

== Дальнейшее видение работы

Для эффективной работы потребуются следующие доработки, в зависимости от поставленной
задачи:

* В примере намеренно не использованны интерфейсы, для упрощения задачи,
но в реальной задаче их применение обязательно;
* *Business* и *Persistence* слои должны обзавестись фасадами для сокрытия их сложности и предоставления одного интерфейса для зависимости от них другими модулями;
* Так же для них должны быть созданы абстрактные фабрики, которые позволят легко
создавать нужные нам объекты, завязанные на интерфейс, а не на реализациюю
* *Communication* слой может быть дополнен слоем *Presentation*,
в случае необходимости разделить логику представления и обращения к приложению